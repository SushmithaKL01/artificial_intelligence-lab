print("Sushmitha KL")

def unify(x, y, substitutions=None):
    if substitutions is None:
        substitutions = {}
    if x == y:
        return substitutions
    if is_variable(x):
        return unify_var(x, y, substitutions)
    if is_variable(y):
        return unify_var(y, x, substitutions)
    if isinstance(x, tuple) and isinstance(y, tuple):
        if x[0] != y[0] or len(x[1]) != len(y[1]):
            return None
        for xi, yi in zip(x[1], y[1]):
            substitutions = unify(apply(substitutions, xi), apply(substitutions, yi), substitutions)
            if substitutions is None:
                return None
        return substitutions
    return None

def unify_var(var, x, substitutions):
    if var in substitutions:
        return unify(substitutions[var], x, substitutions)
    elif occurs_check(var, x, substitutions):
        return None
    else:
        substitutions[var] = x
        return substitutions

def occurs_check(var, x, substitutions):
    if var == x:
        return True
    elif isinstance(x, tuple):
        return any(occurs_check(var, xi, substitutions) for xi in x[1])
    elif isinstance(x, str) and x in substitutions:
        return occurs_check(var, substitutions[x], substitutions)
    return False

def apply(substitutions, expr):
    if isinstance(expr, str):
        return substitutions.get(expr, expr)
    elif isinstance(expr, tuple):
        return (expr[0], [apply(substitutions, e) for e in expr[1]])
    else:
        return expr

def is_variable(x):
    return isinstance(x, str) and len(x) == 1 and x.islower()

def parse(expr):
    expr = expr.replace(" ", "")
    if '(' not in expr:
        return expr
    functor = expr.split('(')[0]
    args = expr[len(functor) + 1:-1]
    parts, depth, start = [], 0, 0
    for i, c in enumerate(args):
        if c == ',' and depth == 0:
            parts.append(args[start:i])
            start = i + 1
        elif c == '(':
            depth += 1
        elif c == ')':
            depth -= 1
    parts.append(args[start:])
    return (functor, [parse(p) for p in parts])

tests = [
    ("p(b,x,f(g(z)))", "p(z,f(y),f(y))"),
    ("Q(a,g(x,a),f(y))", "Q(a,g(f(b),a),x)"),
    ("p(f(a),g(Y))", "p(X,X)"),
    ("prime(11)", "prime(y)"),
    ("knows(John,x)", "knows(y,mother(y))"),
    ("knows(John,x)", "knows(y,Bill)")
]

print(" UNIFICATION RESULTS \n")
for i, (a, b) in enumerate(tests, start=1):
    e1 = parse(a)
    e2 = parse(b)
    result = unify(e1, e2)
    print(f"Q{i}: {a}  AND  {b}")
    if result is None:
        print("MGU = FAIL\n")
    else:
        print("MGU =", result, "\n")
